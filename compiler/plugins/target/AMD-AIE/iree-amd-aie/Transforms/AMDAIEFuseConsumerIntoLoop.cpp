// Copyright 2024 The IREE Authors
//
// Licensed under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#include "iree-amd-aie/Transforms/Passes.h"
#include "mlir/Dialect/SCF/Transforms/TileUsingInterface.h"
#include "mlir/IR/Iterators.h"
#include "mlir/Pass/Pass.h"
//===----------------------------------------------------------------------===//
//                      BLIND COPY OF HEADERS
//===----------------------------------------------------------------------===//
#include "mlir/Analysis/SliceAnalysis.h"
#include "mlir/Dialect/Affine/IR/AffineOps.h"
#include "mlir/Dialect/Arith/IR/Arith.h"
#include "mlir/Dialect/Arith/Utils/Utils.h"
#include "mlir/Dialect/Linalg/IR/Linalg.h"
#include "mlir/Dialect/Linalg/Utils/Utils.h"
#include "mlir/Dialect/MemRef/IR/MemRef.h"
#include "mlir/Dialect/SCF/IR/SCF.h"
#include "mlir/Dialect/Tensor/IR/Tensor.h"
#include "mlir/Dialect/Tensor/Transforms/Transforms.h"
#include "mlir/Dialect/Utils/StaticValueUtils.h"
#include "mlir/IR/PatternMatch.h"
#include "mlir/Interfaces/LoopLikeInterface.h"
#include "mlir/Interfaces/TilingInterface.h"
#include "mlir/Interfaces/ViewLikeInterface.h"

#define DEBUG_TYPE "iree-amdaie-fuse-consumer-into-loop"

namespace mlir::iree_compiler::AMDAIE {

//===----------------------------------------------------------------------===//
//                  BEGIN OF FUSE CONSUMER COPY - AVARMA
//===----------------------------------------------------------------------===//

/// Return the iteration domain range.
SmallVector<Range> getIterationDomain(Operation *op, OpBuilder &b) {
  OpBuilder::InsertionGuard g(b);
  b.setInsertionPoint(op);
  Location loc = op->getLoc();
  linalg::LinalgOp linalgOp = cast<linalg::LinalgOp>(op);
  SmallVector<OpFoldResult> allShapesSizes =
      linalgOp.createFlatListOfOperandDims(b, loc);
  AffineMap map = linalgOp.getShapesToLoopsMap();

  return llvm::to_vector(
      llvm::map_range(map.getResults(), [&](AffineExpr loopExpr) {
        OpFoldResult ofr = affine::makeComposedFoldedAffineApply(
            b, loc, loopExpr, allShapesSizes);
        return Range{b.getIndexAttr(0), ofr, b.getIndexAttr(1)};
      }));
}

static void getMappedOffsetAndSize(linalg::LinalgOp linalgOp, OpBuilder &b,
                                   AffineMap indexingMap,
                                   ArrayRef<OpFoldResult> offsets,
                                   ArrayRef<OpFoldResult> sizes,
                                   SmallVectorImpl<OpFoldResult> &mappedOffsets,
                                   SmallVectorImpl<OpFoldResult> &mappedSizes) {
  unsigned numLoops = linalgOp.getNumLoops();
  auto tilingInterfaceOp = cast<TilingInterface>(linalgOp.getOperation());
  mappedOffsets.resize(numLoops);
  mappedSizes.resize(numLoops);
  if (!indexingMap.isPermutation()) {
    SmallVector<Range> iterationDomain =
        getIterationDomain(tilingInterfaceOp, b);
    for (const auto &&[index, value] : llvm::enumerate(iterationDomain)) {
      mappedOffsets[index] = value.offset;
      mappedSizes[index] = value.size;
    }
  }
  for (const auto &&[index, value] :
       llvm::enumerate(indexingMap.getResults())) {
    unsigned dimPosition = cast<AffineDimExpr>(value).getPosition();
    mappedOffsets[dimPosition] = offsets[index];
    mappedSizes[dimPosition] = sizes[index];
  }
}

/// Return the details of the output tile generated by the tiled
/// implementation.
static LogicalResult getIterationDomainTileFromOperandTile(
    Operation *op, OpBuilder &b, unsigned operandNumber,
    ArrayRef<OpFoldResult> offsets, ArrayRef<OpFoldResult> sizes,
    SmallVectorImpl<OpFoldResult> &iterDomainOffsets,
    SmallVectorImpl<OpFoldResult> &iterDomainSizes) {
  auto linalgOp = cast<linalg::LinalgOp>(op);

  // Check that the indexing map used for the operand is a projected
  // permutation. This could be relaxed with a more general approach that can
  // map the offsets and sizes from the operand to iteration space tiles
  // (filling in full extent for dimensions not used to access the result).
  AffineMap indexingMap =
      linalgOp.getMatchingIndexingMap(&op->getOpOperand(operandNumber));
  if (!indexingMap.isProjectedPermutation()) {
    return emitError(op->getLoc(),
                     "unhandled get iter domain position when operand is not "
                     "accessed using a permuted projection");
  }

  getMappedOffsetAndSize(linalgOp, b, indexingMap, offsets, sizes,
                         iterDomainOffsets, iterDomainSizes);
  return success();
}

/// Instantiate the tiled implementation of the operation.
FailureOr<TilingResult> getTiledImplementation(Operation *op, OpBuilder &b,
                                               ArrayRef<OpFoldResult> offsets,
                                               ArrayRef<OpFoldResult> sizes) {
  // Leave the `sizeBounds` value empty. That is only needed when the `sizes`
  // specified could lead to out of bounds accesses.
  Location loc = op->getLoc();
  linalg::LinalgOp linalgOp = cast<linalg::LinalgOp>(op);
  SmallVector<Value> valuesToTile = linalgOp->getOperands();
  SmallVector<Value, 4> tiledOperands =
      makeTiledShapes(b, loc, linalgOp, valuesToTile, offsets, sizes, {}, true);

  SmallVector<Type> resultTensorTypes =
      getTensorOutputTypes(linalgOp, tiledOperands);

  Operation *tiledOp = clone(b, linalgOp, resultTensorTypes, tiledOperands);
  offsetIndices(b, cast<linalg::LinalgOp>(tiledOp), offsets);

  return TilingResult{{tiledOp}, SmallVector<Value>(tiledOp->getResults())};
}

static FailureOr<TilingResult> getTiledImplementationFromOperandTile(
    Operation *op, OpBuilder &b, unsigned operandNumber,
    ArrayRef<OpFoldResult> offsets, ArrayRef<OpFoldResult> sizes) {
  SmallVector<OpFoldResult> mappedOffsets, mappedSizes;
  auto tilingInterfaceOp = cast<TilingInterface>(op);
  if (failed(getIterationDomainTileFromOperandTile(
          tilingInterfaceOp, b, operandNumber, offsets, sizes, mappedOffsets,
          mappedSizes))) {
    return emitError(
        op->getLoc(),
        "unable to obtain the iter domain position of the operation.");
  }
  return getTiledImplementation(tilingInterfaceOp, b, mappedOffsets,
                                mappedSizes);
}

static FailureOr<TilingResult> replaceInsertSliceWithTiledConsumer(
    OpBuilder &builder, OffsetSizeAndStrideOpInterface sliceOp,
    OpOperand &consumer) {
  auto consumerOp = dyn_cast<TilingInterface>(consumer.getOwner());
  if (!consumerOp) return failure();

  // `TilingInterface` currently only supports strides being 1.
  if (llvm::any_of(sliceOp.getMixedStrides(), [](OpFoldResult ofr) {
        return !isConstantIntValue(ofr, 1);
      }))
    return failure();

  FailureOr<TilingResult> tiledResult = getTiledImplementationFromOperandTile(
      consumerOp, builder, consumer.getOperandNumber(),
      sliceOp.getMixedOffsets(), sliceOp.getMixedSizes());
  if (failed(tiledResult)) return failure();

  return *tiledResult;
}

/// Return the details of the output tile generated by the tiled
/// implementation.
LogicalResult getResultTilePosition(
    Operation *op, OpBuilder &b, unsigned resultNumber,
    ArrayRef<OpFoldResult> offsets, ArrayRef<OpFoldResult> sizes,
    SmallVectorImpl<OpFoldResult> &resultOffsets,
    SmallVectorImpl<OpFoldResult> &resultSizes) {
  Location loc = op->getLoc();
  linalg::LinalgOp linalgOp = cast<linalg::LinalgOp>(op);

  AffineExpr d0;
  bindDims(b.getContext(), d0);
  SmallVector<OpFoldResult> subShapeSizes =
      llvm::to_vector(llvm::map_range(sizes, [&](OpFoldResult ofr) {
        return affine::makeComposedFoldedAffineApply(b, loc, d0 - 1, ofr);
      }));

  OpOperand *outOperand = linalgOp.getDpsInitOperand(resultNumber);
  linalg::SliceParameters sliceParams = linalg::computeSliceParameters(
      b, loc, outOperand->get(), sizes,
      linalgOp.getMatchingIndexingMap(outOperand), offsets,
      /*ubs*/ {}, subShapeSizes, true);
  resultOffsets = sliceParams.offsets;
  resultSizes = sliceParams.sizes;
  return success();
}

/// Fuse the consumer of the source of `candidateSliceOp` by computing the
/// required slice of the consumer in-place.  Note that the method
/// replaces the uses of `candidateSliceOp` with the tiled and fused consumer
/// value but does not delete the slice operation.
struct SCFFuseConsumerOfSliceResult {
  Operation *origConsumer;           // Original untiled consumer.
  Operation *tiledAndFusedConsumer;  // Tiled and fused consumer op.
  SmallVector<Operation *> tiledOps;
};

/// Clones the operation and updates the destination if the operation
/// implements the `DestinationStyleOpInterface`.
static Operation *cloneOpAndUpdateDestinationArgs(RewriterBase &rewriter,
                                                  Operation *op,
                                                  ValueRange newDestArgs) {
  Operation *clonedOp = rewriter.clone(*op);
  if (newDestArgs.empty()) return clonedOp;
  if (auto destinationStyleOp = dyn_cast<DestinationStyleOpInterface>(clonedOp))
    destinationStyleOp.getDpsInitsMutable().assign(newDestArgs);
  return clonedOp;
}

/// A utility function that checks whether the passed value has only one user.
/// In case the defining operation is a tensor.insert_slice, it checks if the
/// user is scf.yield.
static LogicalResult checkAssumptionForFusingConsumer(Value result) {
  Value::use_range uses = result.getUses();
  if (!llvm::hasSingleElement(uses)) {
    LLVM_DEBUG(llvm::dbgs() << "Too many uses of the candidate slice op\n");
    return failure();
  }
  OpOperand &operandUse = (*uses.begin());
  Operation *userOp = operandUse.getOwner();
  if (!isa<scf::YieldOp>(userOp)) {
    LLVM_DEBUG(llvm::dbgs()
               << "Expected scf.yield to be the only user, but got -> "
               << (*userOp));
    return failure();
  }
  return success();
}

/// Fetch the first untiled consumer of a scf.for's result which is yielded by
/// a tensor.insert_slice. This function makes the following assumptions :-
/// 1.  tensor.insert_slice has scf.yield as its only user.
/// 2.  scf.for's corresponding result has only one use.
static OpOperand *getUntiledConsumerFromSlice(
    tensor::InsertSliceOp candidateSliceOp) {
  Value sliceResult = candidateSliceOp.getResult();
  if (failed(checkAssumptionForFusingConsumer(candidateSliceOp.getResult()))) {
    return nullptr;
  }
  // Step 1. Fetch the corresponding output.
  OpOperand &yieldOpOperand = (*sliceResult.getUses().begin());
  unsigned resultNumber = yieldOpOperand.getOperandNumber();
  // Step 2. Check containing op is scf.for.
  Operation *containingOp = candidateSliceOp->getParentOp();
  auto forOp = dyn_cast<scf::ForOp>(containingOp);
  if (!forOp) {
    return nullptr;
  }
  Value resultingValue = forOp->getResult(resultNumber);

  // Step 3. Check resulting value of scf.for has exactly one use.
  if (!llvm::hasSingleElement(resultingValue.getUses())) {
    return nullptr;
  }

  // Step 4. Get uses.
  OpOperand &operand = (*resultingValue.getUses().begin());
  Operation *consumerOp = operand.getOwner();
  // TODO: We have to init result of consumer before scf.for, use
  //       DestinationStyleOpInterface to get result shape from init for now.
  //       Add support for other op such as op has InferTypeOpInterface.
  if (!isa<TilingInterface>(consumerOp) ||
      !isa<DestinationStyleOpInterface>(consumerOp)) {
    return nullptr;
  }
  return &operand;
}

/// Implementation of fusing consumer of a single slice by computing the
/// slice of the consumer in-place for scf.for.
static FailureOr<SCFFuseConsumerOfSliceResult> tileAndFuseConsumerOfSliceSCFFor(
    RewriterBase &rewriter, tensor::InsertSliceOp candidateSliceOp) {
  // 1. Get the consumer of scf.for for the result yielded by
  // tensor.insert_slice.
  OpOperand *consumerOpOperand = getUntiledConsumerFromSlice(candidateSliceOp);
  if (!consumerOpOperand) {
    return rewriter.notifyMatchFailure(candidateSliceOp,
                                       "could not fetch consumer to fuse");
  }
  Operation *consumerOp = consumerOpOperand->getOwner();
  unsigned operandNumber = consumerOpOperand->getOperandNumber();
  unsigned resultNumber =
      cast<OpResult>(consumerOpOperand->get()).getResultNumber();

  auto forOp = candidateSliceOp->getParentOfType<scf::ForOp>();

  OpBuilder::InsertionGuard g(rewriter);
  rewriter.setInsertionPoint(candidateSliceOp);

  auto dstOp = cast<DestinationStyleOpInterface>(consumerOp);
  // 2. Check consumer is not using scf.for's output as init.
  SmallVector<Value> dpsInits =
      llvm::map_to_vector(dstOp.getDpsInits(), [](Value v) { return v; });
  if (llvm::is_contained(dpsInits, forOp.getResult(resultNumber))) {
    return rewriter.notifyMatchFailure(
        consumerOp,
        "consumer op taking the result of scf.for as init is not supported");
  }

  Location loc = forOp.getLoc();
  SmallVector<Value> newOuts(forOp.getInits());
  newOuts.append(dpsInits);

  // 3. Create new scf.for op.
  rewriter.setInsertionPoint(consumerOp);
  auto newforOp = rewriter.create<scf::ForOp>(loc, forOp.getLowerBound(),
                                              forOp.getUpperBound(),
                                              forOp.getStep(), newOuts);
  // 4. Move the loop body to the new op.
  Block *loopBody = forOp.getBody();
  Block *newLoopBody = newforOp.getBody();
  rewriter.mergeBlocks(
      loopBody, newLoopBody,
      newLoopBody->getArguments().take_front(loopBody->getNumArguments()));

  // 5. Clone tensor.insert_slice after original tensor.insert_slice.
  rewriter.setInsertionPointAfter(candidateSliceOp);

  // 6.a. Clone consumer after the cloned tensor.insert_slice op.
  rewriter.setInsertionPointAfter(candidateSliceOp);
  auto newForOpBlockArgsForConsumerDest =
      newLoopBody->getArguments().drop_front(loopBody->getNumArguments());
  auto clonedConsumerOp = cast<TilingInterface>(cloneOpAndUpdateDestinationArgs(
      rewriter, consumerOp, newForOpBlockArgsForConsumerDest));

  // 6.b. Replace all uses of the loop result with the result of the cloned
  // tensor.insert_slice.
  OpOperand &operandToReplace = clonedConsumerOp->getOpOperand(operandNumber);
  rewriter.modifyOpInPlace(clonedConsumerOp, [&]() {
    operandToReplace.set(candidateSliceOp.getResult());
  });

  // 7 - Perform tiling of the cloned consumer.
  rewriter.setInsertionPointAfter(clonedConsumerOp);
  FailureOr<TilingResult> tileAndFuseResult =
      replaceInsertSliceWithTiledConsumer(
          rewriter,
          cast<OffsetSizeAndStrideOpInterface>(candidateSliceOp.getOperation()),
          clonedConsumerOp->getOpOperand(operandNumber));
  if (failed(tileAndFuseResult)) {
    return rewriter.notifyMatchFailure(clonedConsumerOp,
                                       "failed to tile consumer op: ");
  }
  assert(!(tileAndFuseResult->tiledOps.empty()) && "tiled consumer not found");

  // 8 - Extract offset/sizes/strides required to create the tensor.insert_slice
  // for each result of the consumer.
  SmallVector<OpFoldResult> offsets = candidateSliceOp.getMixedOffsets();
  SmallVector<OpFoldResult> sizes = candidateSliceOp.getMixedSizes();
  SmallVector<OpFoldResult> strides = candidateSliceOp.getMixedStrides();
  // 9. Check all insert stride is 1.
  if (llvm::any_of(strides, [](OpFoldResult stride) {
        return !isConstantIntValue(stride, 1);
      })) {
    return rewriter.notifyMatchFailure(
        candidateSliceOp, "containingOp's result yield with stride");
  }
  // 10. Try to get iter domain position from input position.
  SmallVector<OpFoldResult> iterDomainOffsets, iterDomainSizes;
  rewriter.setInsertionPointAfter(clonedConsumerOp);
  if (failed(getIterationDomainTileFromOperandTile(
          clonedConsumerOp, rewriter, operandNumber, offsets, sizes,
          iterDomainOffsets, iterDomainSizes))) {
    return rewriter.notifyMatchFailure(
        clonedConsumerOp, "can't get iter domain position from input position");
  }

  // 11. Try to fetch the offset and size for all results of the cloned
  // consumer. This would then be used to form the corresponding
  // tensor.insert_slice later.
  unsigned totalNumResultsOfConsumer = clonedConsumerOp->getNumResults();
  SmallVector<SmallVector<OpFoldResult>> resultOffsets(
      totalNumResultsOfConsumer);
  SmallVector<SmallVector<OpFoldResult>> resultSizes(totalNumResultsOfConsumer);
  for (auto [idx, v] : llvm::enumerate(clonedConsumerOp->getResults())) {
    if (failed(getResultTilePosition(clonedConsumerOp, rewriter, idx,
                                     iterDomainOffsets, iterDomainSizes,
                                     resultOffsets[idx], resultSizes[idx]))) {
      return rewriter.notifyMatchFailure(
          clonedConsumerOp,
          "can't get result domain position from iter domain position");
    }
  }

  // 12. Fix terminator.
  scf::YieldOp oldTerminatorOp =
      cast<scf::YieldOp>(newforOp.getBody()->getTerminator());
  SmallVector<Value> newYieldOperands(oldTerminatorOp.getResults());
  rewriter.setInsertionPointAfter(oldTerminatorOp);
  MutableArrayRef<BlockArgument> bbArgs = newforOp.getBody()->getArguments();
  for (auto [idx, v] :
       llvm::enumerate(tileAndFuseResult->tiledOps[0]->getResults())) {
    SmallVector<OpFoldResult> strides(resultOffsets[idx].size(),
                                      rewriter.getIndexAttr(1));
    Value newInsertSliceOp = rewriter.create<tensor::InsertSliceOp>(
        candidateSliceOp->getLoc(), v,
        bbArgs[1 + forOp.getInits().size() + idx], resultOffsets[idx],
        resultSizes[idx], strides);
    newYieldOperands.push_back(newInsertSliceOp);
  }
  rewriter.create<scf::YieldOp>(loc, newYieldOperands);
  rewriter.eraseOp(oldTerminatorOp);

  // 13. Replace the result of scf.for and consumer op.
  for (auto &&[oldResult, newResult] :
       llvm::zip_first(forOp.getResults(), newforOp.getResults())) {
    rewriter.replaceAllUsesWith(oldResult, newResult);
  }

  for (auto &&[index, oldValue] : llvm::enumerate(consumerOp->getResults())) {
    rewriter.replaceAllUsesWith(
        oldValue, newforOp->getResult(forOp.getInits().size() + index));
  }

  // 14. Need to erase the old scf.for and the cloned consumer op.
  rewriter.eraseOp(forOp);
  rewriter.eraseOp(clonedConsumerOp);

  return SCFFuseConsumerOfSliceResult{
      consumerOp, tileAndFuseResult->tiledOps[0], {}};
}

/// Fetch the first untiled consumer of a scf.forall's result which is yielded
/// by a tensor.parallel_insert_slice.
static OpOperand *getUntiledConsumerFromSlice(
    tensor::ParallelInsertSliceOp candidateSliceOp) {
  // Step 1. Fetch the corresponding output
  Value sliceDest = candidateSliceOp.getDest();
  auto iterArg = cast<BlockArgument>(sliceDest);
  Operation *containingOp = iterArg.getOwner()->getParentOp();
  // Step 2. Check that the containing op is scf.forall.
  auto forallOp = dyn_cast<scf::ForallOp>(containingOp);
  if (!forallOp) {
    return nullptr;
  }
  // unsigned resultNumber = iterArg.getArgNumber() - forallOp.getRank();
  Value resultingValue =
      forallOp.getTiedOpResult(forallOp.getTiedOpOperand(iterArg));
  // Step 3. Check resulting value of scf.forall has exactly one use.
  Value::use_range uses = resultingValue.getUses();
  if (!llvm::hasSingleElement(uses)) {
    return nullptr;
  }

  // Step 4. Get uses.
  OpOperand &operand = (*resultingValue.getUses().begin());
  Operation *consumerOp = operand.getOwner();
  // TODO: We have to init result of consumer before scf.for, use
  //       DestinationStyleOpInterface to get result shape from init for now.
  //       Add support for other op such as op has InferTypeOpInterface.
  if (!isa<TilingInterface>(consumerOp) ||
      !isa<DestinationStyleOpInterface>(consumerOp)) {
    return nullptr;
  }
  return &operand;
}

/// Implementation of fusing consumer of a single slice by computing the
/// slice of the consumer in-place for scf.forall.
static FailureOr<SCFFuseConsumerOfSliceResult>
tileAndFuseConsumerOfSliceSCFForall(
    RewriterBase &rewriter, tensor::ParallelInsertSliceOp candidateSliceOp) {
  // 1. Get the consumer of the dest.
  OpOperand *consumerOpOperand = getUntiledConsumerFromSlice(candidateSliceOp);
  if (!consumerOpOperand) {
    return rewriter.notifyMatchFailure(candidateSliceOp,
                                       "could not fetch consumer to fuse");
  }
  Operation *consumerOp = consumerOpOperand->getOwner();
  unsigned operandNumber = consumerOpOperand->getOperandNumber();
  unsigned resultNumber =
      cast<OpResult>(consumerOpOperand->get()).getResultNumber();

  OpBuilder::InsertionGuard g(rewriter);
  // Using candidateSliceOp->getParentOp() because we have the following case :-
  // scf.forall.in_parallel {
  //   tensor.parallel_insert_slice ...
  // }
  rewriter.setInsertionPoint(candidateSliceOp->getParentOp());

  Operation *containingOp = candidateSliceOp->getParentOp()->getParentOp();
  auto forallOp = cast<scf::ForallOp>(containingOp);

  auto dstOp = cast<DestinationStyleOpInterface>(consumerOp);
  // 2. Check consumer is not using scf.forall's output as init.
  SmallVector<Value> dpsInits =
      llvm::map_to_vector(dstOp.getDpsInits(), [](Value v) { return v; });
  if (llvm::is_contained(dpsInits, forallOp.getResult(resultNumber))) {
    return rewriter.notifyMatchFailure(
        consumerOp,
        "consumer op taking the result of scf.forall as init is not supported");
  }

  Location loc = forallOp.getLoc();
  // 3. Create new scf.forall op.
  SmallVector<Value> newOuts(forallOp.getOutputs());
  newOuts.append(dpsInits);
  rewriter.setInsertionPoint(consumerOp);
  auto newforallOp = rewriter.create<scf::ForallOp>(
      loc, forallOp.getMixedLowerBound(), forallOp.getMixedUpperBound(),
      forallOp.getMixedStep(), newOuts, forallOp.getMapping());

  // 4. Move the loop body to the new op.
  rewriter.eraseOp(newforallOp.getTerminator());
  Block *loopBody = forallOp.getBody();
  Block *newLoopBody = newforallOp.getBody();
  rewriter.mergeBlocks(
      loopBody, newLoopBody,
      newLoopBody->getArguments().take_front(loopBody->getNumArguments()));

  // 5. Clone tensor.parallel_insert_slice after the original
  // tensor.parallel_insert_slice.
  rewriter.setInsertionPointAfter(candidateSliceOp);

  // 6.a. Clone the consumer after the cloned tensor.parallel_insert_slice.
  rewriter.setInsertionPointAfter(candidateSliceOp);
  auto newForOpBlockArgsForConsumerDest =
      newLoopBody->getArguments().drop_front(loopBody->getNumArguments());
  auto clonedConsumerOp = cast<TilingInterface>(cloneOpAndUpdateDestinationArgs(
      rewriter, consumerOp, newForOpBlockArgsForConsumerDest));

  // 6.b. Replace all uses of the scf.forall's result use in the consumer with
  // the source of the cloned tensor.parallel_insert_slice.
  OpOperand &operandToReplace = clonedConsumerOp->getOpOperand(operandNumber);
  rewriter.modifyOpInPlace(clonedConsumerOp, [&]() {
    operandToReplace.set(candidateSliceOp.getSource());
  });

  // 7. Perform tiling of the cloned consumer.
  rewriter.setInsertionPoint(newforallOp.getTerminator());
  FailureOr<TilingResult> tileAndFuseResult =
      replaceInsertSliceWithTiledConsumer(
          rewriter,
          cast<OffsetSizeAndStrideOpInterface>(candidateSliceOp.getOperation()),
          clonedConsumerOp->getOpOperand(operandNumber));
  if (failed(tileAndFuseResult)) {
    return rewriter.notifyMatchFailure(clonedConsumerOp,
                                       "failed to tile consumer op: ");
  }
  assert(!(tileAndFuseResult->tiledOps.empty()) && "tiled consumer not found");

  // 8. Extract offset/sizes/strides required to create the
  // tensor.parallel_insert_slice for each result of the consumer.
  SmallVector<OpFoldResult> offsets = candidateSliceOp.getMixedOffsets();
  SmallVector<OpFoldResult> sizes = candidateSliceOp.getMixedSizes();
  SmallVector<OpFoldResult> strides = candidateSliceOp.getMixedStrides();
  // 9. Check all insert stride is 1.
  if (llvm::any_of(strides, [](OpFoldResult stride) {
        return !isConstantIntValue(stride, 1);
      })) {
    return rewriter.notifyMatchFailure(
        candidateSliceOp, "containingOp's result yield with stride");
  }
  // 10. Try to get iter domain position from input position.
  SmallVector<OpFoldResult> iterDomainOffsets, iterDomainSizes;
  rewriter.setInsertionPointAfter(tileAndFuseResult->tiledOps[0]);
  if (failed(getIterationDomainTileFromOperandTile(
          clonedConsumerOp, rewriter, operandNumber, offsets, sizes,
          iterDomainOffsets, iterDomainSizes))) {
    return rewriter.notifyMatchFailure(
        clonedConsumerOp, "can't get iter domain position from input position");
  }

  // 11. Try to fetch the offset and size for all results of the cloned
  // consumer. This would then be used to form the corresponding
  // tensor.parallel_insert_slice later.
  unsigned totalNumResultsOfConsumer = clonedConsumerOp->getNumResults();
  SmallVector<SmallVector<OpFoldResult>> resultOffsets(
      totalNumResultsOfConsumer);
  SmallVector<SmallVector<OpFoldResult>> resultSizes(totalNumResultsOfConsumer);
  for (auto [idx, v] : llvm::enumerate(clonedConsumerOp->getResults())) {
    if (failed(getResultTilePosition(clonedConsumerOp, rewriter, idx,
                                     iterDomainOffsets, iterDomainSizes,
                                     resultOffsets[idx], resultSizes[idx]))) {
      return rewriter.notifyMatchFailure(
          clonedConsumerOp,
          "can't get result domain position from iter domain position");
    }
  }

  // 12. Fix terminator.
  scf::InParallelOp newTerminatorOp = newforallOp.getTerminator();
  rewriter.setInsertionPointToStart(newTerminatorOp.getBody());
  Location firstYieldOpLoc =
      (*(newTerminatorOp.getYieldingOps().begin())).getLoc();
  MutableArrayRef<BlockArgument> bbArgs = newforallOp.getBody()->getArguments();
  for (auto [idx, v] :
       llvm::enumerate(tileAndFuseResult->tiledOps[0]->getResults())) {
    SmallVector<OpFoldResult> strides(resultOffsets[idx].size(),
                                      rewriter.getIndexAttr(1));
    rewriter.create<tensor::ParallelInsertSliceOp>(
        firstYieldOpLoc, v,
        bbArgs[forallOp.getRank() + forallOp.getOutputs().size() + idx],
        resultOffsets[idx], resultSizes[idx], strides);
  }

  // 13. Replace the result of scf.forall and consumer op.
  for (auto &&[oldResult, newResult] :
       llvm::zip_first(forallOp.getResults(), newforallOp.getResults())) {
    rewriter.replaceAllUsesWith(oldResult, newResult);
  }

  for (auto &&[index, oldValue] : llvm::enumerate(consumerOp->getResults())) {
    rewriter.replaceAllUsesWith(
        oldValue, newforallOp->getResult(forallOp.getOutputs().size() + index));
  }

  // 14. Need to erase the old scf.forall and cloned consumer.
  rewriter.eraseOp(forallOp);
  rewriter.eraseOp(clonedConsumerOp);

  return SCFFuseConsumerOfSliceResult{
      consumerOp, tileAndFuseResult->tiledOps[0], {}};
}

/// Implementation of fusing consumer of a single slice by computing the
/// slice of the consumer in-place.
static FailureOr<SCFFuseConsumerOfSliceResult> tileAndFuseConsumerOfSlice(
    RewriterBase &rewriter, Operation *candidateSliceOp) {
  if (auto sliceOp = dyn_cast<tensor::InsertSliceOp>(candidateSliceOp)) {
    return tileAndFuseConsumerOfSliceSCFFor(rewriter, sliceOp);
  } else if (auto sliceOp =
                 dyn_cast<tensor::ParallelInsertSliceOp>(candidateSliceOp)) {
    return tileAndFuseConsumerOfSliceSCFForall(rewriter, sliceOp);
  } else {
    return failure();
  }
}

//===----------------------------------------------------------------------===//
//                  END OF FUSE CONSUMER COPY - AVARMA
//===----------------------------------------------------------------------===//
namespace {

class AMDAIEFuseConsumerIntoLoopPass
    : public impl::AMDAIEFuseConsumerIntoLoopBase<
          AMDAIEFuseConsumerIntoLoopPass> {
 public:
  AMDAIEFuseConsumerIntoLoopPass() = default;
  AMDAIEFuseConsumerIntoLoopPass(const AMDAIEFuseConsumerIntoLoopPass &pass) {}
  AMDAIEFuseConsumerIntoLoopPass(
      const AMDAIEFuseConsumerIntoLoopOptions &options)
      : AMDAIEFuseConsumerIntoLoopBase(options) {}

  void getDependentDialects(DialectRegistry &registry) const override {
    registry.insert<scf::SCFDialect>();
  }
  void runOnOperation() override;
};

void AMDAIEFuseConsumerIntoLoopPass::runOnOperation() {
  MLIRContext *context = &getContext();
  mlir::FunctionOpInterface funcOp = getOperation();
  IRRewriter rewriter(context);

  // Walk through the graph in post order and find the loop.
  Operation *scfLoopOp = nullptr;
  funcOp->walk<WalkOrder::PostOrder, ReverseIterator>(
      [&](LoopLikeOpInterface op) {
        if (isa<scf::ForOp>(op) && useSCFFor) {
          scfLoopOp = op;
          return WalkResult::interrupt();
        } else if (isa<scf::ForallOp>(op) && !useSCFFor) {
          scfLoopOp = op;
          return WalkResult::interrupt();
        }
        return WalkResult::advance();
      });

  if (!scfLoopOp) {
    LLVM_DEBUG(llvm::dbgs()
               << "There is no scf.for/forall loop to fuse with.\n");
    return;
  }

  LoopLikeOpInterface loops = cast<LoopLikeOpInterface>(scfLoopOp);
  auto loopBody = useSCFFor ? cast<scf::ForOp>(loops).getBody()
                            : cast<scf::ForallOp>(loops).getBody();

  // Search the compute op and its consumer slices.
  linalg::LinalgOp linalgOp;
  loopBody->walk<WalkOrder::PostOrder, ReverseIterator>(
      [&](linalg::LinalgOp op) {
        if (linalg::isaContractionOpInterface(op)) {
          linalgOp = op;
          return WalkResult::interrupt();
        }
        return WalkResult::advance();
      });

  if (!linalgOp) {
    LLVM_DEBUG(llvm::dbgs()
               << "----- Could not find any linalg op implementing "
                  "ContractionOpInterface \n");
    return;
  }

  Value::user_range users = linalgOp->getResult(0).getUsers();
  if (!llvm::hasSingleElement(users)) {
    LLVM_DEBUG(llvm::dbgs()
               << "----- Expected only one user of the compute op : "
               << linalgOp << "\n");
    return;
  }

  Operation *terminatorStoreOp = *(users.begin());
  if (!(isa<tensor::InsertSliceOp, tensor::ParallelInsertSliceOp>(
          terminatorStoreOp))) {
    LLVM_DEBUG(llvm::dbgs()
               << "----- Expected either tensor.insert_slice OR "
                  "tensor.parallel_insert_slice to be the only user of the "
                  "compute op : "
               << linalgOp << "\n");
    return;
  }

  if (!terminatorStoreOp) {
    LLVM_DEBUG(llvm::dbgs()
               << "----- Consumer ops are already fused it seems \n");
    return;
  }

  std::optional<SCFFuseConsumerOfSliceResult> fusedConsumer =
      tileAndFuseConsumerOfSlice(rewriter, terminatorStoreOp);
  if (!fusedConsumer) {
    funcOp->emitOpError("Failed to fuse consumer ops into for loop.");
    return signalPassFailure();
  }
}

}  // namespace

std::unique_ptr<Pass> createAMDAIEFuseConsumerIntoLoopPass(
    AMDAIEFuseConsumerIntoLoopOptions options) {
  return std::make_unique<AMDAIEFuseConsumerIntoLoopPass>(options);
}

}  // namespace mlir::iree_compiler::AMDAIE
